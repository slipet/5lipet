# 2025

## Weekly contest [#470](https://leetcode.cn/discuss/post/3798458/di-470-chang-zhou-sai-by-leetcode-ne73/)

Q1. Compute Alternating Sum

### Q2. Longest Subsequence With Non-Zero Bitwise XOR

??? note "Details"
    這題很快想到至少某一位bit的數量必須是奇數可以xor全部，否則剔除一個數做xor，第一發wa因為沒考慮到有0的情況，第二發wa是沒考慮到全為0的情況

    * <span style="color:red">要確認題目的邊界</span>

### Q3. Remove K-Balanced Substrings

* tag: stack

??? note "Details"
    讀完題馬上想到要用stack，但是在狀態設計上沒有考慮清楚，在k = 2 的時候 若是長這樣 (() (())) ，會先消除兩個 () 然後剩下一個 )
    可以跟左邊留下來的部分再次組成 (()) 做消除。

    * <span style="color:red">腦袋不清楚，沒睡飽</span>
    * <span style="color:red">測資想的不夠全面</span>
    * <span style="color:red">或許可以考慮寫個對拍?</span>

### Q4. Count No-Zero Pairs That Sum to

* tag: digit dp

??? note "Details"
    看完題目馬上想到數位DP，但是只考慮了從高位至低位，(a,b)中枚舉a的時候如果含有0或是不含0的情況，但是沒辦法處理另外一半含有0的情況
    因為若是 total - (a有0的情況) ，則只會計算 (a有0的情況, b), (a有0的情況, b有0的情況) 這種情況，沒辦法處理 (a, b有0的情況)。

    * <span style="color:red">想到這邊或許應該馬上放棄思考這條路徑?</span>

    * Solution:

        真正的解法應該使用<span style="color:red">從低位到高位</span>。

        * a + b = n 從基本的加法開始觀察

            1. 設當前數位為 d = s[i]。如果低位 (i + 1) 發生借位 -> d - 1
            2. d 可以像高位借位 -> d + 10
            3. 如果 d = 0 ， 如果此時低位借位了，必須同時向高位借位 -> d = -1, d + 10 = 9

        * 拆分方案數:
            
            * $d = a + b$ 且 $a,b \in [1, 9]$

            1. 若是不借位則， (a, b) = (1, d - 1), (2, d - 2) ... ..., (d - 1, 1)

                \[
                cnt((a, b)) = \left\{ 
                \begin{array}{ll}
                    d - 1, & \text{for } d >= 2\\
                    0,     & \text{for } d < 2
                \end{array}
                \right.
                \]

            2. 若是向高位借一位，則要算 d + 10 = a + b的方案數，ex. 14 = (5, 9), (6, 8), (7, 7), (8, 6), (9, 4)，
            則會發現 $(a, b) = (d + 1, d + 10 - (d + 1)), (d + 2, d + 10 - (d + 2)) ... = (d + x, 10 - x)$
            ，一共有 9 - d(a < d 有多少個) 個也就是 19 - (d + 10) 個

        * 前導 0:

            * d = a + b 時，至少有一位是 0

            * 若 a = 0，則更高位的 a' 必須也是 0 -> 前導 0

            * 此時 b = d

            * 分類討論:

                * 若 d != 0:
                    * b = d 只有一種，若是 d < 0 則要借位
                    * 剛開始填前導 0 時，可以利用對稱性把方案數 * 2
                * 若 d = 0， 則 b = d = 0:
                    * 若是 i > 0，因為沒有向高位借位，b的高位至少一個非0數字b，前面不能都是0 -> 無解
                    * 否則 i=0，兩個數的最高位都是 0，這是合法的。例如 100 = 49+51，49 和 51 的百位都是前導零。
    
    * [code](https://leetcode.cn/problems/count-no-zero-pairs-that-sum-to-n/solutions/3798539/cong-di-wang-gao-de-shu-wei-dppythonjava-r8dh/)

    * 補充題目:

        * [F. Jee, You See?](https://codeforces.com/problemset/problem/1670/F)

## Weekly contest [#471](https://leetcode.cn/contest/weekly-contest-471/)

Q1. Sum of Elements With Frequency Divisible by K

Q2. Longest Balanced Substring I (4 points)

### Q3. Longest Balanced Substring II

??? note "Details"

    * Thought in the contest:

        最一開始的時候想到了前綴和，滑動窗口這幾個想法。
        
        * 滑動窗口的部分沒有好的方式限制窗口

        * 前綴和的方式後來有想到 01010 這種方式若是可以讓前綴和為 0 就可以找到頻率一樣的區間了。對於 (a, b), (a, c), (b, c) 都可以找，但是卡在了
        (a, b, c) 這上面沒想到如何解決 a + b + c = 0 的情況。

    * Solution:

        * <span style="color:red">對於某個子字串如果要符合要求那必須，$cntA_{[l,r]} = cntB_{[l,r]} = cntC_{[l,r]}$。接著拆分成 </span>

        \[
            \left\{ 
                \begin{array}{ll}
                    cntA_{[l,r]} = cntB_{[l,r]}\\
                    cntB_{[l,r]} = cntC_{[l,r]}
                \end{array}
            \right.
        \]

        移項後

        \[
            \left\{ 
                \begin{array}{ll}
                    cntA_{[l,r]} - cntB_{[l,r]} = 0\\
                    cntB_{[l,r]} - cntC_{[l,r]} = 0
                \end{array}
            \right.
        \]

        * 若是子字串的中的 $(cntA_{[l,r]} - cntB_{[l,r]}, cntB_{[l,r]} - cntC_{[l,r]})$ 相等表示這段子區間內的頻率相同。
        
        * <span style="color:red">這裡有個容易錯的地方是前綴和會有負數，用 long long 似乎因為負數會導致hash錯，所以要加 n 使得 hash 非負數</span>

### Q4. Sum of Perfect Square Ancestors

* tag: [平方剩餘和預處理](https://slipet.github.io/5lipet/math/number_theory/#_3)

??? note "Details"

    * Thought in the contest:

        這題困難點在如何提取出平方剩餘和，也就是奇數次方的乘積。

    * Solution:

        要用類似埃式篩的方式計算
    
    * 類似題目:

        * [完全平方数的祖先个数总和](https://leetcode.cn/problems/sum-of-perfect-square-ancestors/description/)

        * [完全子集的最大元素和](https://leetcode.cn/problems/maximum-element-sum-of-a-complete-subset-of-indices/description/)

## Weekly contest [#472](https://leetcode.cn/contest/weekly-contest-472/)

Q1. Smallest Missing Multiple of K

??? note "Details"
    因為粗心 wa 一發
    
    * <span style="color:red">沒利用極值測試</span>

Q2. Longest Balanced Subarray I

??? note "Details"

    * <span style="color:red">要寫暴力的話，就寫單純的方法就好，不要花力氣去想複雜的方法</span>
    * <span style="color:red">速度太慢</span>

Q3. Lexicographically Smallest Permutation Greater Than Target

??? note "Details"

    這題有抓到問題的本質，<span style="color:red">字典序最小的話就要沿著目標字串構造，一但有無法構造的部分就是從那個位置開始構造。</span>

    * <span style="color:red">少想一個邊界值 wa 了一發，順序過去找到關鍵位置後要往回走，類似反悔貪心。</span>

Q4. Longest Balanced Subarray II

??? note "Details"

    這題跟上禮拜的很類似，都是利用 +1/-1 前綴和為 0 的性質找個數相等的子區間，但是對於重複元素的部分無法考慮清楚，比賽的時候卡在這部分。

    [講解](https://leetcode.cn/problems/longest-balanced-subarray-ii/solutions/3809924/fen-kuai-wei-hu-qian-zhui-he-pythonjavac-rt79/)

    有想到對於重複元素應該使得其貢獻為 0, 但是我使用的想法是對於第一個出現的元素 +1 or -1 這會導致對於前綴和無法得到對應的區間 -> 問題所在

    * <span style="color:red">雖然有觀察到對於重複元素如果可以選，那應該越多越好 -> 想到這個應該要想到哪一個元素當第一個元素比較適合?</span>
    * 在前綴和的框架下我們會不斷的枚舉右端點，此時對於子區間會造成貢獻的是第一個出現的元素，之後出現的重複元素對於前綴和應當都是 0。
    * 接著就會帶到，如果向右枚舉出現一個重複元素，那必須把這個元素當成第一個元素，左邊的其他元素的貢獻應該改為 0  -> 要做區間修改的操作 -> 線段樹/BIT
    * 接著我們想找區間合為 0 的前綴和位置 -> 線段樹二分 -> 用 {min, max} 表達區間內的最大最小值(因為前綴和值的變化是整數連續的) -> lazy 線段樹

    題目:
        * [HH 的项链](https://www.luogu.com.cn/problem/P1972)

## Weekly contest [#473](https://leetcode.cn/discuss/post/3815591/di-473-chang-zhou-sai-by-leetcode-ykt9/)

Q1. Remove Zeros in Decimal Representation

Q2. Maximum Alternating Sum of Squares
    
Q3. Stable Subarrays With Equal Boundary and Interior Sum
    
??? note "Details"

    用 pair 的方式要看一下思路，這樣不用二重 hash。

    [tutorial](https://leetcode.cn/problems/stable-subarrays-with-equal-boundary-and-interior-sum/description/)

Q4. Count Distinct Subarrays Divisible by K in Sorted Array

??? note "Details"

    一開始想到利用統計 [0, k - 1] 結尾的個數方式計算 subarray。

    * <span style="color:red">想到一半的時候已經想到可能會 TLE ，因為 $O(nk)$，但還是執意去做因為猜可能 k 循環次數會比較少，應該馬上放棄這個想法才對</span>

    * <span style="color:red">另外調整太久才得到 TLE 的答案，沒想清楚</span>

    [tutorial](https://leetcode.cn/problems/count-distinct-subarrays-divisible-by-k-in-sorted-array/solutions/3815647/qian-zhui-he-yu-ha-xi-biao-bi-mian-zhong-nc4l/)

## Weekly contest [#474](https://leetcode.cn/discuss/post/3821305/di-474-chang-zhou-sai-by-leetcode-yi6w/)

Q1. Find Missing Elements

Q2. Maximum Product of Three Elements After One Replacement

Q3. Minimum Time to Complete All Deliveries

Q4. Lexicographically Smallest Palindromic Permutation Greater Than Target

??? note "Details"

    * Thought in the contest:

    比賽的時候沒有找到正確的思路，因為回文的限制導致沒看清題目的本質。

    比賽的時候想的思路是先沿著target利用 lower_bound 在 s 中找答案，如果沒辦法產生一個合法解那就往回撤銷直到可以構造出一個 >= target 的解。

    這個想法跟答案其實很接近，問題出在一開始使用 lower_bound 找 >= target 的可行解，但是 lower_bound 不保證最後得到的答案會是最小的。

    * Solution:

    這題跟 [3720. 大于目标字符串的最小字典序排列](https://leetcode.cn/problems/lexicographically-smallest-permutation-greater-than-target/description/) 的思路是一樣的。

    先想辦法盡可能沿著 target 構造一個初步可行解，直到沒辦法繼續構造為止，此時產生出來的字串會是最小的，接著我們必須產生出剛好大於等於 target 的合法解，如果剩下來的字母無法構造的話，那就往回撤銷之前已經填好的字母嘗試構造，直到有合法解為止。

    [題解](https://leetcode.cn/problems/lexicographically-smallest-palindromic-permutation-greater-than-target/solutions/3821437/on-dao-xu-tan-xin-pythonjavacgo-by-endle-zips/)

## Weekly contest [#475](https://leetcode.com/discuss/post/7335991/weekly-contest-475-by-leetcode-dqpl/)

Q4. Maximize Cyclic Partition Score

??? note "Details"

    * Thought in the contest:

        比賽的時候想到的是從無環的情況出發做約束劃分型dp(O(nk))，但是當考慮到環後會因為處理環的情況導致複雜度爆炸。

    * Solution:

        對於沒有環形的約束下，整體的題目框架是股票交易模型 [3573. 买卖股票的最佳时机 V](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-v/description/)，其中子陣列中只有最大最小值是有意義的其他不關心。

        * <span style="color:red">换句话说，3573 题可以更抽象地描述为，划分成至多 k 段子数组的极差之和的最大值。</span>
        
        可以寫成:

        \begin{array}{ll}
                max\sum_{i = 1}^{k} = |a_{r_i} - a_{l_i}|
            \end{array}
        
        用max轉換成:

        \begin{array}{ll}
            \sum_{i = 1}^{k} = max(a_{r_i} - a_{l_i}, a_{l_i} - a_{r_i})
        \end{array}
          
        * <span style="color:red">環型陣列的題目突破點應該是如何處理環形陣列，也就是說如何把環形攤平成普通陣列做計算。</span>

            這題攤平成普通陣列的方法是考量到最大元素必定會包含在某一子陣列中，以及我們只考量子陣列中的最大最小值，所以我們可以貪心的將最大值截斷將其當成陣列的開頭或是結尾，把環形陣列攤平。
        
        [code](https://leetcode.cn/problems/maximize-cyclic-partition-score/solutions/3827101/zhao-dao-zui-jia-duan-huan-wei-zhi-zhuan-k2ip/)

## Weekly contest [#476](https://leetcode.com/discuss/post/7351255/weekly-contest-476-by-leetcode-pir7/)

Q4. Count Stable Subarrays

??? note "Details"

    * Thought in the contest:
        
        比賽的時候被逆序對給迷惑住了，一直思考如何有效率的計算全部的順序 subarray，並且最後考慮實作莫隊，結果在分塊交界的邏輯卡住了。

    * Solution:

        比賽結束後看到把每個順序 subarray 做分塊，馬上就完成了，基本上也算是個套路題，透過將每個順序 subarray 分組 + 前綴和可以有效率的算出區間內的答案。

        其中要注意的是題解的套路，對於一個順序的 subarray，可以透過累加當前長度的方式得到這個區間的解，而我們需要分別將左右兩邊單獨計算和利用前綴和直接計算中間部分。

        [code](https://leetcode.cn/problems/count-stable-subarrays/solutions/3832945/fen-duan-er-fen-cha-zhao-qian-zhui-he-py-ukgs/)

## Weekly contest [#477](https://leetcode.cn/contest/weekly-contest-477/)

Q3. Concatenate Non-Zero Digits and Multiply by Sum II

??? note "Details"

    這題因為不熟悉 string hash 所以搞了很久，不過可以透過這題來複習 string hash。

    [link](https://leetcode.cn/problems/concatenate-non-zero-digits-and-multiply-by-sum-ii/solutions/3839697/san-ge-qian-zhui-he-pythonjavacgo-by-end-6e1a/)

Q4. Number of Effective Subsequences

??? note "Details"

    * Thought in the contest:

        比賽得時候有想到是不是 SOS DP，但是想的不夠深入，此外時間不夠所以沒寫出來，另外比賽的時候把 or 看成 xor。

    * Solution:

        題目要求計算全部元素 or 後 < x 的子序列個數，但是直接統計 < x 是相對麻煩的。所以反向計算: or(all elements) - >= x 的子序列個數。
        然而又因為 or(all elements) 不會超過 x 所以 -> or(all elements) - (=x 的子序列個數)。

        接著要計算子序列恰好等於 x 是困難的 -> 至多/少 x 比較好算(這裡用子集的方式表示，至多在這裡指的是 $\in$ )

        用容斥原理計算:
        ex. $or = 11_2$ 的方案數為 $2^{f{11}} - 2^{f{10}} - 2^{f{01}} + 2^{f{00}}$

        接著要計算在 nums 中有多少個數(元素個數)是 S 的子集 -> SOS DP

## Weekly contest [#477](https://leetcode.cn/contest/weekly-contest-478/)

Q1. Count Elements With at Least K Greater Values

??? note "Details"

    因為沒理解題意導致 wa 了五次，下次 w 兩次後要回去確認題意。

Q4. Minimum Operations to Equalize Subarrays
