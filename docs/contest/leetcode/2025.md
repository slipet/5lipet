# 2025

## Weekly contest [#470](https://leetcode.cn/discuss/post/3798458/di-470-chang-zhou-sai-by-leetcode-ne73/)

Q1. Compute Alternating Sum

### Q2. Longest Subsequence With Non-Zero Bitwise XOR

??? note "Details"
    這題很快想到至少某一位bit的數量必須是奇數可以xor全部，否則剔除一個數做xor，第一發wa因為沒考慮到有0的情況，第二發wa是沒考慮到全為0的情況

    * <span style="color:red">要確認題目的邊界</span>

### Q3. Remove K-Balanced Substrings

* tag: stack

??? note "Details"
    讀完題馬上想到要用stack，但是在狀態設計上沒有考慮清楚，在k = 2 的時候 若是長這樣 (() (())) ，會先消除兩個 () 然後剩下一個 )
    可以跟左邊留下來的部分再次組成 (()) 做消除。

    * <span style="color:red">腦袋不清楚，沒睡飽</span>
    * <span style="color:red">測資想的不夠全面</span>
    * <span style="color:red">或許可以考慮寫個對拍?</span>

### Q4. Count No-Zero Pairs That Sum to

* tag: digit dp

??? note "Details"
    看完題目馬上想到數位DP，但是只考慮了從高位至低位，(a,b)中枚舉a的時候如果含有0或是不含0的情況，但是沒辦法處理另外一半含有0的情況
    因為若是 total - (a有0的情況) ，則只會計算 (a有0的情況, b), (a有0的情況, b有0的情況) 這種情況，沒辦法處理 (a, b有0的情況)。

    * <span style="color:red">想到這邊或許應該馬上放棄思考這條路徑?</span>

    * Solution:

        真正的解法應該使用<span style="color:red">從低位到高位</span>。

        * a + b = n 從基本的加法開始觀察

            1. 設當前數位為 d = s[i]。如果低位 (i + 1) 發生借位 -> d - 1
            2. d 可以像高位借位 -> d + 10
            3. 如果 d = 0 ， 如果此時低位借位了，必須同時向高位借位 -> d = -1, d + 10 = 9

        * 拆分方案數:
            
            * $d = a + b$ 且 $a,b \in [1, 9]$

            1. 若是不借位則， (a, b) = (1, d - 1), (2, d - 2) ... ..., (d - 1, 1)

                \[
                cnt((a, b)) = \left\{ 
                \begin{array}{ll}
                    d - 1, & \text{for } d >= 2\\
                    0,     & \text{for } d < 2
                \end{array}
                \right.
                \]

            2. 若是向高位借一位，則要算 d + 10 = a + b的方案數，ex. 14 = (5, 9), (6, 8), (7, 7), (8, 6), (9, 4)，
            則會發現 $(a, b) = (d + 1, d + 10 - (d + 1)), (d + 2, d + 10 - (d + 2)) ... = (d + x, 10 - x)$
            ，一共有 9 - d(a < d 有多少個) 個也就是 19 - (d + 10) 個

        * 前導 0:

            * d = a + b 時，至少有一位是 0

            * 若 a = 0，則更高位的 a' 必須也是 0 -> 前導 0

            * 此時 b = d

            * 分類討論:

                * 若 d != 0:
                    * b = d 只有一種，若是 d < 0 則要借位
                    * 剛開始填前導 0 時，可以利用對稱性把方案數 * 2
                * 若 d = 0， 則 b = d = 0:
                    * 若是 i > 0，因為沒有向高位借位，b的高位至少一個非0數字b，前面不能都是0 -> 無解
                    * 否則 i=0，兩個數的最高位都是 0，這是合法的。例如 100 = 49+51，49 和 51 的百位都是前導零。
    
    * [code](https://leetcode.cn/problems/count-no-zero-pairs-that-sum-to-n/solutions/3798539/cong-di-wang-gao-de-shu-wei-dppythonjava-r8dh/)

    * 補充題目:

        * [F. Jee, You See?](https://codeforces.com/problemset/problem/1670/F)

## Weekly contest [#471](https://leetcode.cn/contest/weekly-contest-471/)

Q1. Sum of Elements With Frequency Divisible by K

Q2. Longest Balanced Substring I (4 points)

### Q3. Longest Balanced Substring II

??? note "Details"

    * Thought in the contest:

        最一開始的時候想到了前綴和，滑動窗口這幾個想法。
        
        * 滑動窗口的部分沒有好的方式限制窗口

        * 前綴和的方式後來有想到 01010 這種方式若是可以讓前綴和為 0 就可以找到頻率一樣的區間了。對於 (a, b), (a, c), (b, c) 都可以找，但是卡在了
        (a, b, c) 這上面沒想到如何解決 a + b + c = 0 的情況。

    * Solution:

        * <span style="color:red">對於某個子字串如果要符合要求那必須，$cntA_{[l,r]} = cntB_{[l,r]} = cntC_{[l,r]}$。接著拆分成 </span>

        \[
            \left\{ 
                \begin{array}{ll}
                    cntA_{[l,r]} = cntB_{[l,r]}\\
                    cntB_{[l,r]} = cntC_{[l,r]}
                \end{array}
            \right.
        \]

        移項後

        \[
            \left\{ 
                \begin{array}{ll}
                    cntA_{[l,r]} - cntB_{[l,r]} = 0\\
                    cntB_{[l,r]} - cntC_{[l,r]} = 0
                \end{array}
            \right.
        \]

        * 若是子字串的中的 $(cntA_{[l,r]} - cntB_{[l,r]}, cntB_{[l,r]} - cntC_{[l,r]})$ 相等表示這段子區間內的頻率相同。
        
        * <span style="color:red">這裡有個容易錯的地方是前綴和會有負數，用 long long 似乎因為負數會導致hash錯，所以要加 n 使得 hash 非負數</span>

### Q4. Sum of Perfect Square Ancestors

??? note "Details"

    * Thought in the contest:

        這題困難點在如何提取出平方剩餘和，也就是奇數次方的乘積。

    * Solution:

        要用類似埃式篩的方式計算
    
    * 類似題目:

        * [完全平方数的祖先个数总和](https://leetcode.cn/problems/sum-of-perfect-square-ancestors/description/)

        * [完全子集的最大元素和](https://leetcode.cn/problems/maximum-element-sum-of-a-complete-subset-of-indices/description/)
