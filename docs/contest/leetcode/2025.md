# 2025

## Weekly contest [#470](https://leetcode.cn/discuss/post/3798458/di-470-chang-zhou-sai-by-leetcode-ne73/)

Q1 - Compute Alternating Sum

Q2 - Longest Subsequence With Non-Zero Bitwise XOR

??? note "Details"
    這題很快想到至少某一位bit的數量必須是奇數可以xor全部，否則剔除一個數做xor，第一發wa因為沒考慮到有0的情況，第二發wa是沒考慮到全為0的情況

    * <span style="color:red">要確認題目的邊界</span>

Q3 - Remove K-Balanced Substrings

* tag: stack

??? note "Details"
    讀完題馬上想到要用stack，但是在狀態設計上沒有考慮清楚，在k = 2 的時候 若是長這樣 (() (())) ，會先消除兩個 () 然後剩下一個 )
    可以跟左邊留下來的部分再次組成 (()) 做消除。

    * <span style="color:red">腦袋不清楚，沒睡飽</span>
    * <span style="color:red">測資想的不夠全面</span>
    * <span style="color:red">或許可以考慮寫個對拍?</span>

Q4 - Count No-Zero Pairs That Sum to

* tag: digit dp

#??? note "Details"
看完題目馬上想到數位DP，但是只考慮了從高位至低位，(a,b)中枚舉a的時候如果含有0或是不含0的情況，但是沒辦法處理另外一半含有0的情況
因為若是 total - (a有0的情況) ，則只會計算 (a有0的情況, b), (a有0的情況, b有0的情況) 這種情況，沒辦法處理 (a, b有0的情況)。

* <span style="color:red">想到這邊或許應該馬上放棄思考這條路徑?</span>

* Solution:

    真正的解法應該使用<span style="color:red">從低位到高位</span>。

    * a + b = n 從基本的加法開始觀察

        1. 設當前數位為 d = s[i]。如果低位 (i + 1) 發生借位 -> d - 1
        2. d 可以像高位借位 -> d + 10
        3. 如果 d = 0 ， 如果此時低位借位了，必須同時向高位借位 -> d = -1, d + 10 = 9

* 補充題目:

    * [F. Jee, You See?](https://codeforces.com/problemset/problem/1670/F)
