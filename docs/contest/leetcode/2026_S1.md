# 2026 S1

## Weekly contest [#483](https://leetcode.cn/contest/weekly-contest-483/)

因為網路的關係這場 unrated

Q4. Minimum Cost to Merge Sorted Lists

狀壓 DP + 二分算中位數，一開始還想用複雜的對頂堆維護算中位數，後來看到有人說二分馬上想出來，比賽的時候有可能因為這樣就沒寫出來。

---

## Biweekly contest [#173](https://leetcode.cn/contest/biweekly-contest-173/)

雙周賽補題

Q3. Find Maximum Value in a Constrained Sequence

做來回兩次遍歷陣列，第一次由左向右使陣列維持 diff 和 restrictions 的限制，第二次由右向左調整使得 restrictions 的限制符合 diff 。

Q4. Count Routes to Climb a Rectangular Grid 

前綴和優化 DP，這題沒有很難但是要想清楚陣列如何轉移，以及前綴和的處理。

---

## Weekly contest [#484](https://leetcode.cn/contest/weekly-contest-484/)

Q3. Count Caesar Cipher Pairs

因為回傳值寫錯忘記改卡了好久。

Q4. Maximum Bitwise AND After Increment Operations

雖然一開始有想到要逐位元做貪心，想用排序後由大至小找大小為 m 的子集，但是這種貪心是錯的，因為比較大的元素不代表成本比較少。

這題還是要從貢獻法下手。假設我們想要使子集 AND 後得到 target t，表示有 m 個元素 $x_i$ 做完操作 ${ops}_i$ 後可以得到 $(x_i + {ops}_i) \text{ & } t = t$，我們的目標是使 $\sum_{i = 0}^{m - 1}{{ops}_i} \le k$，能得到最大的 target t 。

對於第 j 位元 $b_j$，元素 $x_i$ 我們要知道 $x_i$ 要做多少操作才可以使 $b_j$ 為 1，我們可以寫成這樣 $ops_{(i,j)} = b_j - (x_i \text{ & } ((b_j << 1) - 1))$，因為我們只關心比 $b_j$ 小的位元的貢獻，得到貢獻後可以用快排或是快速選擇，如果前 m 最小貢獻 $\sum_{i = 0}^{m - 1}{{ops}_i} \le k$ 表示可以透過操作得到 $b_j$。

因為答案要求最後的目標 t 儘量大，所以從最大的位元往低位計算可能的 t，若是最後得到的 $\sum_{i = 0}^{m - 1}{{ops}_i} \le k$ ，表示當前的 $b_j$ 可以加入 t，而我們需要利用這個 t 去計算貢獻

---

## Weekly contest [#485](https://leetcode.cn/contest/weekly-contest-485/)

Q2. Maximum Capacity Within Budget

這題我用的是 sort + bit，但是可以用 sort + monotonic stack

Q4. Lexicographically Smallest String After Deleting Duplicate Characters

這題腦袋不清楚，理解錯題意，以為是要用兩種字母配對，結果題目意思是可刪除的字母出現兩次以上。

基本的貪心思想是，要使比較小的字母儘量靠前，因此按順序遍歷，一旦遇到比較小的字母就把前面的刪除。

最後得到的答案還要再次維護使得答案長度儘量小。

## Weekly contest [#486](https://leetcode.cn/contest/weekly-contest-486/)

Q4. Find Nth Smallest Integer With K One Bits

這題很快就想到用組合數算有 m 個 1 和 n 個 0 的組合數是 $C_{m + n - 1}^{m}$，所以可以計算出需要有幾個 0 才能構造出答案

但是這個方式讓我在構造答案的時候完全卡住。

這題考的是試填法，真正的做法是由高至低位按位元填入。假設目前在第 i bit 填 0 ，那接下來要在剩下的 p 個位置填 k 個 1 的方案數為 $\binom{p}{k}$ ，若此時 $n \le \binom{p}{k}$，表示第 n 個數會在 $\binom{p}{k}$ 的方案數中，所以第 i bit可以填 0，否則要填 1，然後將問題規模縮小成在剩下的 p - 1 個位置填 k - 1 個 1 的方案數，並將 $n = n - \binom{p}{k}$。

## Weekly contest [#488](https://leetcode.cn/contest/weekly-contest-488/)

Q4. Maximum Score Using Exactly K Pairs

比賽的時候一直往枚舉選哪個的方向去思考，結果最後卡住沒寫出來，賽後觀察發現是子序列 DP 選或不選後馬上解決。

子序列DP:

相鄰相關 -> 選或不選
相鄰無關 -> 枚舉選哪個 e.g. 最長遞增子序列 LIS

## Weekly contest [#489](https://leetcode.cn/contest/weekly-contest-489/)

Q3. Longest Almost-Palindromic Substring

一開始看到題目想用 DP 的方向思考，但是發現對於使用跳過操作後的轉移有點難以解決，中間雖然有想過使用刷表法，但是還是沒有做出來。

最後解答是中心擴展法，雖然中間有想過使用這個方式，但是沒想到我的模板居然有寫錯，最後沒有發現，其實這題很簡單，不需要使用DP的方式就可以算出來，因為 n 很小。

Q4. Maximum Subarray XOR with Bounded Range

這題一開始看到最大最小馬上反應到單調隊列，但是對於找 subarray 中的最大 XOR 沒有想法，雖然想說是不是使用前綴和之類的想法但是嘗試了一下之後回去想 Q3。

看了解答後發現，使用前綴和的想法沒有錯，但是最後找子陣列中最大 XOR 的方法是要使用 0/1 trie 解決，假設當前綴和為 1100，我們想找的另一個可以組成最大的值為 0011，因此我們要利用 0/1 trie 沿著最高位找是否有對應的值在子陣列。