# 2026 S1

## Weekly contest [#483](https://leetcode.cn/contest/weekly-contest-483/)

因為網路的關係這場 unrated

Q4. Minimum Cost to Merge Sorted Lists

狀壓 DP + 二分算中位數，一開始還想用複雜的對頂堆維護算中位數，後來看到有人說二分馬上想出來，比賽的時候有可能因為這樣就沒寫出來。

---

## Biweekly contest [#173](https://leetcode.cn/contest/biweekly-contest-173/)

雙周賽補題

Q3. Find Maximum Value in a Constrained Sequence

做來回兩次遍歷陣列，第一次由左向右使陣列維持 diff 和 restrictions 的限制，第二次由右向左調整使得 restrictions 的限制符合 diff 。

Q4. Count Routes to Climb a Rectangular Grid 

前綴和優化 DP，這題沒有很難但是要想清楚陣列如何轉移，以及前綴和的處理。

---

## Weekly contest [#484](https://leetcode.cn/contest/weekly-contest-484/)

Q3. Count Caesar Cipher Pairs

因為回傳值寫錯忘記改卡了好久。

Q4. Maximum Bitwise AND After Increment Operations

雖然一開始有想到要逐位元做貪心，想用排序後由大至小找大小為 m 的子集，但是這種貪心是錯的，因為比較大的元素不代表成本比較少。

這題還是要從貢獻法下手。假設我們想要使子集 AND 後得到 target t，表示有 m 個元素 $x_i$ 做完操作 ${ops}_i$ 後可以得到 $(x_i + {ops}_i) \text{ & } t = t$，我們的目標是使 $\sum_{i = 0}^{m - 1}{{ops}_i} \le k$，能得到最大的 target t 。

對於第 j 位元 $b_j$，元素 $x_i$ 我們要知道 $x_i$ 要做多少操作才可以使 $b_j$ 為 1，我們可以寫成這樣 $ops_{(i,j)} = b_j - (x_i \text{ & } ((b_j << 1) - 1))$，因為我們只關心比 $b_j$ 小的位元的貢獻，得到貢獻後可以用快排或是快速選擇，如果前 m 最小貢獻 $\sum_{i = 0}^{m - 1}{{ops}_i} \le k$ 表示可以透過操作得到 $b_j$。

因為答案要求最後的目標 t 儘量大，所以從最大的位元往低位計算可能的 t，若是最後得到的 $\sum_{i = 0}^{m - 1}{{ops}_i} \le k$ ，表示當前的 $b_j$ 可以加入 t，而我們需要利用這個 t 去計算貢獻

---

## Weekly contest [#485](https://leetcode.cn/contest/weekly-contest-485/)

Q2. Maximum Capacity Within Budget

這題我用的是 sort + bit，但是可以用 sort + monotonic stack

Q4. Lexicographically Smallest String After Deleting Duplicate Characters

這題腦袋不清楚，理解錯題意，以為是要用兩種字母配對，結果題目意思是可刪除的字母出現兩次以上。

基本的貪心思想是，要使比較小的字母儘量靠前，因此按順序遍歷，一旦遇到比較小的字母就把前面的刪除。

最後得到的答案還要再次維護使得答案長度儘量小。
