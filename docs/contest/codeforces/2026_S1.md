# 2026 S1


## [Codeforces Round 1075 (Div. 2)](https://codeforces.com/blog/entry/150452)

C1. XOR Convenience (Easy Version)

卡在這題完全沒想法，雖然一眼就看出 $p_i \oplus i = p_j$，最後想到的方法是使用一個set不斷地從剩下最大的元素做 xor 直到 $p_i \oplus i$ 的值出現在剩下的元素中。

看了解答發現這題主要的想法會是，由第 n - 1 個元素出發，可以知道 $p_{n-1} \oplus (n - 1) = p_n$ 這是必定成立，因為後面只剩 $p_n$，所以一種貪心想法是，能不能構造出一種排列使得 $i \oplus p_n = p_{i}$，可以發現 $p_n = 1$ 時在 i = 2k 時有 $2k \oplus 1 = 2k + 1$，在 $i = 2k + 1$ 時 $2k + 1 \oplus 1 = 2k$。

因此可以將 i 利用奇偶性質將 i 分成 2k, 2k + 1。

當 n 為偶數時，可以做這樣的分配 ex. n = 10, $[p_1, 3, 2, 5, 4, 7, 6, 9, 8, 1]$，此時 $p_1 = 10$ 

當 n 為奇數時，可以做這樣的分配 ex. n = 9, $[p_1, 3, 2, 5, 4, 7, 6, 9, 1]$，此時 $p_1 = 8$ 

因此可以有這樣結論 

\[
p_1 = 
\left\{
\begin{array}{ll}
    n \text{, n is even} \\
    n \oplus 1 \text{, n is odd} 
\end{array}
\right.
\]

\[
\left\{
\begin{array}{ll}
    p_i = i \oplus 1 \text{, for } i \in [2, n - 1] \\
    p_n = 1
\end{array}
\right.
\]

C2. XOR-convenience (Hard Version)

顯然的對於 2 的冪次方($2, 4, ... 2^x$)是無解的，因為 $2^x \oplus y = 2^x + y \ge 2^x$，因為值域為 $[1, 2^x]$ 所以這種情況是無解的。

考慮當 $n \neq 2^x$ 的情況:

由 C1 可以知道當 n 為奇數時， $p_1 = n - 1$，此時 n - 1 為偶數，所以 $p_1 \oplus 1 = (n - 1) \oplus 1 = n$，所以當 n 為奇數時可以直接套用 C1 的方法。

當 n 為偶數時，$p_1 = n$，此時 $p_1 \oplus 1$ 可能會產生大於 n 的數值，所以這樣無法構造出一個合法的解，因此把 $n$ 分解成 $n = 2^x + r\text{, } r < 2^x$，我們可以把 $p_1$ 跟 $p_r$ 交換，可以得到對於 $i = r$:

$$r \oplus p_1 = r \oplus n = r \oplus 2^x + r = 2^x$$

而從 $r < 2^x$，可以知道後面有一個 $p_j = 2^x$。

對於 $i = 1$:

$$1 \oplus p_r = 1 \oplus (r \oplus 1) = r$$

而可以知道對於 $p_{r + 1} = r + 1 \oplus 1$，由這個方法可以構造出一個合法解。

以 n = 10 為例子, $[p_1, 3, 2, 5, 4, 7, 6, 9, 8, 1]$，此時 $p_1 = 10$，而 $p_1 \oplus 1 = 11$ 是一個不合法的排列，我們可以將 $10$ 拆解成 $8 + 2$ 可以將 $p_1 = 10$ 跟 $p_2 = 3$ 進行交換，得到 $[3, 10, 2, 5, 4, 7, 6, 9, 8, 1]$ 的排列，可以檢查 $1 \oplus 3 = 2$

