# 2026 S1


## [Codeforces Round 1075 (Div. 2)](https://codeforces.com/blog/entry/150452)

C1. XOR Convenience (Easy Version)

卡在這題完全沒想法，雖然一眼就看出 $p_i \oplus i = p_j$，最後想到的方法是使用一個set不斷地從剩下最大的元素做 xor 直到 $p_i \oplus i$ 的值出現在剩下的元素中。

看了解答發現這題主要的想法會是，由第 n - 1 個元素出發，可以知道 $p_{n-1} \oplus (n - 1) = p_n$ 這是必定成立，因為後面只剩 $p_n$，所以一種貪心想法是，能不能構造出一種排列使得 $i \oplus p_n = p_{i}$，可以發現 $p_n = 1$ 時在 i = 2k 時有 $2k \oplus 1 = 2k + 1$，在 $i = 2k + 1$ 時 $2k + 1 \oplus 1 = 2k$。

因此可以將 i 利用奇偶性質將 i 分成 2k, 2k + 1。

當 n 為偶數時，可以做這樣的分配 ex. n = 10, $[p_1, 3, 2, 5, 4, 7, 6, 9, 8, 1]$，此時 $p_1 = 10$ 

當 n 為奇數時，可以做這樣的分配 ex. n = 9, $[p_1, 3, 2, 5, 4, 7, 6, 9, 1]$，此時 $p_1 = 8$ 

因此可以有這樣結論 

\[
p_1 = 
\left\{
\begin{array}{ll}
    n \text{, n is even} \\
    n \oplus 1 \text{, n is odd} 
\end{array}
\right.
\]

\[
\left\{
\begin{array}{ll}
    p_i = i \oplus 1 \text{, for } i \in [2, n - 1] \\
    p_n = 1
\end{array}
\right.
\]

C2. XOR-convenience (Hard Version)
