# 2025

## Round [#1055](https://codeforces.com/blog/entry/146988) (Div.1 + Div.2)

A - Increase or Smash
??? note "Details"
    * Thought in the contest:
    
    直接模擬過程，有仔細思考很不錯，但是速度偏慢，可以先使用比較簡單的範例。


B - Catching the Krug
??? note "Details"
    * Thought in the contest:

        一開始想到了要往四個角落走，並且同時想到了可以使用9宮格確認兩個人的相對位置，但是在如何確定該怎麼選擇要往哪走時卡住了。

    * Solution:

        \[
        r_{dis} = \left\{ 
        \begin{array}{ll}
            r_k < r_d \to r_d\\
            r_k > r_d \to n - r_d\\
            r_k = r_d \to 0
        \end{array}
        \right.
        \]

        \[
        c_{dis} = \left\{ 
        \begin{array}{ll}
            c_k < c_d \to c_d\\
            c_k > c_d \to n - c_d\\
            c_k = c_d \to 0
        \end{array}
        \right.
        \]

        用簡單的貪心可以發現，Doran必須要往邊界走，而Krug則是要往Doran的遠離方向走，則Doran抵達邊界的距離為 $max(r_{dis}, c_{dis})$ 。

C - Triple Removal

* tag: prefix sum

??? note "Details"

    * Thought in the contest:

        觀察到需要三個分成一組，所以可以利用前綴和 O(1) 計算 [l, r] 中有多少 1/0，當 1/0 的個數無法整除3時回答 -1 。因為 cost 為三個 $idx_i, idx_j, idx_k$ 一組中兩兩之間 $min(d_{i, j}, d_{j, k})$ 距離，此時該怎麼將 [l, r] 分組? 
        
        * <span style="color:red">簡單的貪心將最近的三個idx分成一組。這邊思考錯誤 !!!</span>

        * <span style="color:red">題目沒讀清楚!消除三個元素後，剩下的元素會合併成一個新的陣列。</span>

    * Solution:
        
        必須觀察出可能每次都可以挑出一對相鄰的pair加上某個元素進行消除 -> $|r - l + 1| / 3$

        除非 101010 或是 010101 ，這種一開始須要選隔兩個進行消除，然後再做跟原來一樣的操作 
        所以可以得到:

        1. 如果 $[l, r] % 3 != 0$ 

            -> -1

        2. 如果有 $l \le i \le r$ 且 $a_i = a_{i + 1}$

            -> |r - l + 1| / 3

        3. 無法使用 2. 的可能陣列為 010101... 或 101010...
            
            -> 2 + (r - l + 1 - 3) / 2 ，相當於消去三個元素，剩下的長度算結果

        如何判斷 010101/101010 ?
        利用01/10變化當作diff[i]，用前綴和的方式計算，若是整個區間都是10或是01則diff[i]都會是1，那區間和會等於區間長度

        <span style="color:red">這邊在實作的時候一直錯，因為我們詢問的區間是 [l, r]，所以變化的前綴和區間是 [l + 1, r] = diff[r] - diff[l]</span>

D - Division Versus Addition
??? note "Details"

## Educational Round 183 [] [#183](https://codeforces.com/blog/entry/146988) (Rated for Div. 2)

A - 

B - 

C - 

tag: prefix, sufix

??? note "Details"
    * Thought in the contest:

        所求為移除一段 subarray 使得剩下的 a 和 b 個數相等。馬上想到前綴和總合為0的轉換技巧，但是在計算移除最小的 subarray 時卡關。
        原本想說 利用 pre - x = 0 移項的方式找 x = pre 的長度，但是這樣是錯的!

        中間有想到將全部的陣列重複一次拼接成一個 2 * n 的陣列，並且求出最長 pre = 0 的 subarray，但是這種作法需要處理兩端相交的情形，以及
        初始為空的情況，變得很複雜。

        <span style="color:red">第一個解法其實隱約覺得有點怪怪的，可能還是要盡可能嘗試想個反例</span>
        
        <span style="color:red">想得太複雜應該要重新reset，整理現有的資訊重新思考</span>

    * Solution:
        比賽結束後想到應該是要做前後綴分解才對，先計算後綴和，並且將後綴和分組儲存其 index 值，枚舉前綴合的時候，需要找的是可以 pre[i] + suf[j] = 0
        的對應後綴和 index 此時必須 i < j 。對於前後綴和為 0 的情況必須特別討論，因為為 0 時可以不需要另一半前/後綴就可以為 0。

D - 