# 2025

## Round [#1055](https://codeforces.com/blog/entry/146988) (Div.1 + Div.2)

### A. Increase or Smash
??? note "Details"
    * Thought in the contest:
    
    直接模擬過程，有仔細思考很不錯，但是速度偏慢，可以先使用比較簡單的範例。


### B. Catching the Krug
??? note "Details"
    * Thought in the contest:

        一開始想到了要往四個角落走，並且同時想到了可以使用9宮格確認兩個人的相對位置，但是在如何確定該怎麼選擇要往哪走時卡住了。

    * Solution:

        \[
        r_{dis} = \left\{ 
        \begin{array}{ll}
            r_k < r_d \to r_d\\
            r_k > r_d \to n - r_d\\
            r_k = r_d \to 0
        \end{array}
        \right.
        \]

        \[
        c_{dis} = \left\{ 
        \begin{array}{ll}
            c_k < c_d \to c_d\\
            c_k > c_d \to n - c_d\\
            c_k = c_d \to 0
        \end{array}
        \right.
        \]

        用簡單的貪心可以發現，Doran必須要往邊界走，而Krug則是要往Doran的遠離方向走，則Doran抵達邊界的距離為 $max(r_{dis}, c_{dis})$ 。

### C. Triple Removal

* tag: prefix sum

??? note "Details"

    * Thought in the contest:

        觀察到需要三個分成一組，所以可以利用前綴和 O(1) 計算 [l, r] 中有多少 1/0，當 1/0 的個數無法整除3時回答 -1 。因為 cost 為三個 $idx_i, idx_j, idx_k$ 一組中兩兩之間 $min(d_{i, j}, d_{j, k})$ 距離，此時該怎麼將 [l, r] 分組? 
        
        * <span style="color:red">簡單的貪心將最近的三個idx分成一組。這邊思考錯誤 !!!</span>

        * <span style="color:red">題目沒讀清楚!消除三個元素後，剩下的元素會合併成一個新的陣列。</span>

    * Solution:
        
        必須觀察出可能每次都可以挑出一對相鄰的pair加上某個元素進行消除 -> $|r - l + 1| / 3$

        除非 101010 或是 010101 ，這種一開始須要選隔兩個進行消除，然後再做跟原來一樣的操作 
        所以可以得到:

        1. 如果 $[l, r] % 3 != 0$ 

            -> -1

        2. 如果有 $l \le i \le r$ 且 $a_i = a_{i + 1}$

            -> |r - l + 1| / 3

        3. 無法使用 2. 的可能陣列為 010101... 或 101010...
            
            -> 2 + (r - l + 1 - 3) / 2 ，相當於消去三個元素，剩下的長度算結果

        如何判斷 010101/101010 ?
        利用01/10變化當作diff[i]，用前綴和的方式計算，若是整個區間都是10或是01則diff[i]都會是1，那區間和會等於區間長度

        <span style="color:red">這邊在實作的時候一直錯，因為我們詢問的區間是 [l, r]，所以變化的前綴和區間是 [l + 1, r] = diff[r] - diff[l]</span>

D. Division Versus Addition


## Educational Round [#183](https://codeforces.com/contest/2145) (Rated for Div. 2)

A. Candies for Nephews

### B. Deck of Cards

tag: greedy

??? note "Details"    
    
    * Thought in the contest:
        剛開始想說若是一遇到操作三後面的數字也都是會受到操作三的影響，但是從給出的測資無法跟我的想匹配，最後發現是要將操作三留到最後先使用操作一跟操作二。


### C. Monocarp's String

tag: prefix, sufix

??? note "Details"
    * Thought in the contest:

        所求為移除一段 subarray 使得剩下的 a 和 b 個數相等。馬上想到前綴和總合為0的轉換技巧，但是在計算移除最小的 subarray 時卡關。
        原本想說 利用 pre - x = 0 移項的方式找 x = pre 的長度，但是這樣是錯的!

        中間有想到將全部的陣列重複一次拼接成一個 2 * n 的陣列，並且求出最長 pre = 0 的 subarray，但是這種作法需要處理兩端相交的情形，以及
        初始為空的情況，變得很複雜。

        <span style="color:red">第一個解法其實隱約覺得有點怪怪的，可能還是要盡可能嘗試想個反例</span>
        
        <span style="color:red">想得太複雜應該要重新reset，整理現有的資訊重新思考</span>

    * Solution:

        比賽結束後想到應該是要做前後綴分解才對，先計算後綴和，並且將後綴和分組儲存其 index 值，枚舉前綴合的時候，需要找的是可以 pre[i] + suf[j] = 0
        的對應後綴和 index 此時必須 i < j 。對於前後綴和為 0 的情況必須特別討論，因為為 0 時可以不需要另一半前/後綴就可以為 0。

D. Inversion Value of a Permutation

## Round [#1057](https://codeforces.com/blog/entry/147264) (Div.2)

A. Circle of Apple Trees

### B. Bitwise Reversion

??? note "Details"

    * Thought in the contest:
        
        <span style="color:red">Attention is all you need!!!</span>

        一開始讀完題目沒有很好的思路，接著嘗試將每個bit列出來，也沒有想法，最後把 a, b, c 當成 set 把圖畫出來，並且配合 bit 才想到是不是去掉所有的交集後剩下的交集要各自獨立才能滿足題目的不等式。

        \[
        \left\{ 
            \begin{array}{ll}
                a \& b = (1) + (2) = x \\
                b \& c = (2) + (4) = y \\
                a \& c = (2) + (3) = z
            \end{array}
        \right.
        \]

        去掉 $a \& b \& c = (2)$ 後 (1), (3), (4) 必須各自獨立也就是說兩兩必不會有交集，否則與題目的限制會有矛盾。

        [code](https://codeforces.com/contest/2153/submission/342973774)

        ![photo](../../assets/imgs/B_Bitwise_Reversion.png)

### C. Symmetrical Polygons

??? note "Details"

    * Thought in the contest:

        這題雖然一開始就有一個很直觀的想法，但是中間因為 edge case 卡住導致直到比賽結束都沒有做出來，不然應該算是一題秒殺題。

        基本的想法就是對長度進行分組，對於某個長度 x 數量 > 1 的邊可以將其分到兩個組別 a, b，接著將剩下一個的邊按照順序放到一個陣列當中。

        接著要利用 a, b 中的邊組合出多邊形，我們可以使用 1, 2 個邊組合出多邊形。並不是任何的邊都可以組合出多邊形，以三角形為例子，其中兩個邊必定要大於第三邊，用腦內思考就很容易得到。

        讓我卡住的地方是

        1. <span style="color:red">對於額外兩個邊(c, d)的情況必須要 a + b + c > d ，否則會無法形成多邊形</span>
            
            [-a-] [-c-] [-b-]

            [--------d--------]

        2. <span style="color:red">雖然想到上面的條件但是還有一個部分，但是有可能最大的幾條邊都沒辦法滿足，所以其實要遍歷陣列分別加一條邊的情況，或是兩條邊的情況，取最大值。</span>

        [code](https://codeforces.com/contest/2153/submission/343028233)

### D. Not Alone

??? note "Details"

    * Thought in the contest:

        一看到題目聯想到了打家劫舍的問題，因為一旦選了往前或往後其中一個方向必須相同那就似乎可以用類似打家劫舍的方式定義狀態。但是對於轉移方程沒辦法很好的確定。想了很久都沒辦法突破。

    * Solution:

        偷看了提示後發現要分成 2 個 和 3 個元素做劃分型DP，一旦知道分成 2 個或是 3 個後，想使用遞推的方式做DP但是發現有點難定義初始值，最後用記憶化搜索很順利的就完成了。

        * <span style="color:red">分成 2 個做劃分很容易想到，但是分成 3 個做劃分的思路要仔細的理解，因為這是這題的關鍵</span>

            * 這題跟打家劫舍還是不一樣。首先把陣列切割成長度為 2 的區塊，此時很容易發現長度為 3 的陣列無法用長度為 2 的區塊組合而成，此時應當想到要用長度為 3 的區塊做劃分。對於長度 > 4 的區塊可以把它切割成 長度為 2 和 3 的兩種區塊組合。

        * <span style="color:red">雖然用記憶化很容易實作，但還是要練習先在白板上寫記憶化的 pseudo code 之後再轉成遞推的形式，因為怕之後可能遇到沒辦法用記憶化的題目</span>

        [code](https://codeforces.com/contest/2153/submission/343085025)

        * <span style="color:red">對於環形陣列的處理，可以學習 [jiazhichen844](https://codeforces.com/contest/2153/submission/342948873) 的處理，將 多出來的部分拼接在陣列的前後，接著就是當作普通的陣列做計算</span>

        [code](https://codeforces.com/contest/2153/submission/343153883)

        ```cpp
        auto dp = [&](int offset) -> LL {
            vector<LL> f(n + 1, invalid);
            f[0] = 0;
            f[2] = costA(0 + offset, 1 + offset);
            for(int i = 2; i < n; ++i) {
                f[i + 1] = min(f[i - 1] + costA(i - 1 + offset, i + offset), \
                                f[i - 2] + costB(i - 2 + offset, i - 1 + offset, i + offset));
            }
            return f[n];
        };
        ```

        * <span style="color:red">注意 f 和 cost 使用的下標是不一樣的意思 </span>

## Round [#1059](https://codeforces.com/blog/entry/147242) (Div.3)

### A. Beautiful Average

### B. Beautiful String

??? note "Details"

    * Thought in the contest:

        一開始沒看懂題目，wa 了一發，之後仔細看了一下題目然後過了。

### C. Beautiful XOR

### D. Beautiful Permutation

??? note "Details"

    * Thought in the contest:

        第一次寫交互題，調了很久輸入輸出最後時間快到才調好，賽後沒過多久就過了。

    * <span style="color:red">交互題的模板要整理好</span>

### E. Beautiful Palindromes

??? note "Details"

    * Thought in the contest:
        
        有想到核心想法，只要確保回文中心無法構成，那就無法構成。

    * Solution:

## Round [#1061](https://codeforces.com/blog/entry/147761) (Div.2)

### C. Maximum GCD on Whiteboard

??? note "Details"

    * Thought in the contest:
        
        比賽的時候有想到利用不等式 $x \le y + x \le kx$，但是之後就卡住沒辦法往下推。

    * Solution:

        考慮若是 g 作為答案要如何拆分 $X = x_1 + x_2 + x_3$:

        (1) 非常明顯的若是 $X \le 4g$ 無法將 X 拆分使得 $x_1, x_3 \ge g$，所以只能選擇 $X = g, 2g, 3g$

        (2) 若是 $4g \le X \le 5g$，我們可以這樣分配 $x_1 = g, x_2 = g + (X \% g), x_3 = 2g$

        (3) 若是 $X \ge 5g$，我們可以這樣分配 $x_1 = g, x_2 = g + (X \% g), x_3 = 3g$

        * <span style="color:red">分類討論的能力要加強</span>

        (4) 接著是如果用 $g = 1, 2, 3, .. n$ 去遍歷陣列時間複雜度會是 $O = (n^2)$ ，所以我們需要一個方式可以 $O(1)$ 得到陣列中 $g, 2g, 3g, \ge 4g$ 的元素個數 -> 前綴和

        * <span style="color:red">用值域方式思考</span

        [code](https://codeforces.com/contest/2156/submission/345729493)


